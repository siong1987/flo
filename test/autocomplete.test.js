// Generated by CoffeeScript 1.3.3
(function() {
  var assert, async, flo, _;

  flo = require('../index').connect();

  async = require('async');

  _ = require('underscore');

  assert = require('assert');

  module.exports = {
    'test prefixes_for_phrase': function() {
      var result;
      result = flo.prefixes_for_phrase("abc");
      assert.eql(["a", "ab", "abc"], result);
      result = flo.prefixes_for_phrase("abc abc");
      assert.eql(["a", "ab", "abc"], result);
      result = flo.prefixes_for_phrase("how are you");
      return assert.eql(["h", "ho", "how", "a", "ar", "are", "y", "yo", "you"], result);
    },
    'test key': function() {
      var result;
      result = flo.key("fun", "abc");
      return assert.equal("flo:fun:abc", result);
    },
    'test add_term': function() {
      var term, term_data, term_id, term_score, term_type;
      term_type = 'book';
      term_id = 1;
      term = "Algorithms for Noob";
      term_score = 10;
      term_data = {
        ISBN: "123AOU123",
        Publisher: "Siong Publication"
      };
      return flo.add_term(term_type, term_id, term, term_score, term_data, function() {
        return async.parallel([
          (function(callback) {
            return flo.redis.hget(flo.key(term_type, "data"), term_id, function(err, reply) {
              var result;
              result = JSON.parse(reply);
              assert.equal(term, result.term);
              assert.equal(term_score, result.score);
              assert.eql(term_data, result.data);
              return callback();
            });
          }), (function(callback) {
            var _this = this;
            return async.map(flo.prefixes_for_phrase(term), (function(w, cb) {
              return flo.redis.zrange(flo.key(term_type, "index", w), 0, -1, cb);
            }), function(err, results) {
              assert.equal(17, results.length);
              results = _.uniq(_.flatten(results));
              assert.equal(1, results[0]);
              return callback();
            });
          })
        ]);
      });
    },
    'test search_term': function() {
      var venues;
      venues = require('../samples/venues').venues;
      return async.series([
        (function(callback) {
          return async.forEach(venues, (function(venue, cb) {
            return flo.add_term("venues", venue.id, venue.term, venue.score, venue.data, function() {
              return cb();
            });
          }), callback);
        }), (function(callback) {
          return flo.search_term(["venues", "food"], "stadium", function(err, results) {
            assert.equal(3, results.venues.length);
            return callback();
          });
        }), (function(callback) {
          return flo.search_term(["venues"], "stadium", 1, function(err, results) {
            assert.equal(1, results.venues.length);
            return callback();
          });
        })
      ]);
    },
    'test remove_term': function() {
      var all_data, term, term_data, term_id, term_id2, term_id3, term_score, term_type;
      term_type = "foods";
      term_id = 2;
      term_id2 = 3;
      term_id3 = 4;
      term = "Burger";
      term_score = 10;
      term_data = {
        temp: "data"
      };
      all_data = {
        id: term_id,
        term: term,
        score: term_score,
        data: term_data
      };
      return async.series([
        (function(next) {
          return flo.add_term(term_type, term_id, term, term_score, term_data, next);
        }), (function(next) {
          return flo.get_ids(term_type, term, function(err, ids) {
            assert.isNull(err);
            assert.eql(ids, [term_id]);
            return next();
          });
        }), (function(next) {
          return flo.get_data(term_type, term_id, function(err, data) {
            assert.isNull(err);
            assert.eql(data, all_data);
            return next();
          });
        }), (function(next) {
          return flo.add_term(term_type, term_id2, term, term_score, term_data, next);
        }), (function(next) {
          return flo.get_ids(term_type, term, function(err, ids) {
            assert.isNull(err);
            assert.eql(ids, [term_id, term_id2]);
            return next();
          });
        }), (function(next) {
          return flo.add_term(term_type, term_id3, term, term_score, term_data, next);
        }), (function(next) {
          return flo.remove_term(term_type, term_id2, next);
        }), (function(next) {
          return flo.remove_term(term_type, term_id, next);
        }), (function(next) {
          return flo.get_ids(term_type, term, function(err, ids) {
            assert.eql(ids, [term_id3]);
            return next();
          });
        }), (function(next) {
          return flo.remove_term(term_type, term_id3, next);
        }), (function(next) {
          return flo.remove_term(term_type, term_id, function(err) {
            assert.isNotNull(err);
            return next();
          });
        }), (function(next) {
          return flo.get_ids(term_type, term, function(err, ids) {
            assert.eql(ids, []);
            return next();
          });
        }), (function(next) {
          return flo.search_term([term_type], term, function(err, result) {
            var eql;
            eql = {
              term: term
            };
            eql[term_type] = [];
            assert.eql(result, eql);
            return next();
          });
        })
      ], function(err, results) {
        return flo.end();
      });
    }
  };

}).call(this);
